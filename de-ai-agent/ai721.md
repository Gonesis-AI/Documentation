---
description: Make AI agent indexable and verifiable on the blockchain.
---

# AI721

> Version: 0.2
>
> Last Updated: 2024-06-15

## Introduction

### What is AI721

AI721 introduces a standard that extends the AI capabilities of ERC721. It's used to index AI agent on  chain, describe the AI personality and copabilities of your AI agent, and verify if a specific personality belongs to a particular AI agent. **This makes your AI agent become digital asset on the blockchain.**

AI721 will not make any break changes on ERC721. It can be merged with ERC721, or deployed as an independent contract and associated with an existing ERC721 contract.

**Yes, AI721 is essentially NFT(non-fungible token) with AI capabilities**.&#x20;

We call it **AI-NFT** for short.

### Why we need AI721

LLMs enable everyone to create AI personalities with any prompts. You can create any kinds of characters with different personalities with some tools like [character.ai](https://character.ai). **However, it's centralized, non-transparent, and unable to achieve consensus.**

If we want to describe AI personalities in a decentralized environment , and access it without relying on any centralized 3rd parties, we need to define a standard to implement this process, ensuring that anyone can obtain the same AI personality through the same protocol.

**AI721 is the key to make it happen.**

## How it works

In the AI721 protocol, the AI Personality of an AI-NFT is defined by these core components below:

* **LLM**: The large language model that can comprehend and generate human language text. It provides basic AI capabilities for your AI-NFT.
* **Trait model**: A collection-level function that inputs the AI-NFT's traits and outputs a set of prompts, defining the independent personality that is only related to its traits, as an initial state.&#x20;
* **Memory**: The memories, or knowledge that form the final AI personality, manifested through promps in conversation with the AI agent.&#x20;
  * **Public Memory:** A predefined and public memory that anyone can use to form an AI personality.
  * **Private Memory:** A user-level private memory that shared with your AI agent, can be only read by the NFT owner.
* **Workflow:** A workflow is defined as a structured sequence of operations that organizes tasks into manageable steps. Compatible with the data structure of the workflow on [dify.ai](https://docs.dify.ai/features/workflow/introduce).

### How to describe AI Agent on chain?

#### AI Metadata Standard

AI721 defines a new kind of JSON metadata to describe an AI personality. The metadata standard includes three important parameters to index the AI personality. This metadata is different from the one for ERC721, and can be stored on-chain or off-chain.

<table><thead><tr><th width="255">Parameter</th><th width="147">Format</th><th>Description</th></tr></thead><tbody><tr><td><code>llm</code></td><td>URI</td><td><p>The uri to access <strong>LLM</strong> that is stored in off-chain storages.</p><p><br>Check <a data-mention href="ai721.md#uri-format-supported">#uri-format-supported</a>.</p></td></tr><tr><td><code>trait_model</code></td><td>string/URI</td><td>The prompt template that generates the final prompts from the traits and other storyline of AI-NFT, by using placeholders of the form <code>${trait_type}</code> , to define an independent and unique personality.<br><br>Check <a data-mention href="ai721.md#trait-model-example">#trait-model-example</a>.</td></tr><tr><td><code>public_memories</code></td><td>URI</td><td><p>(Optional) The uri to access the <strong>list</strong> of public memories needed to form an AI agent. </p><p></p><p>The application layer can choose from these memories to create specific AI agents, like a virtual lawyer, math teacher, or virtual girlfriend/boyfriend.<br><br>Check <a data-mention href="ai721.md#uri-format-supported">#uri-format-supported</a>and <a data-mention href="ai721.md#memory-structure">#memory-structure</a>.</p></td></tr><tr><td><code>workflow</code></td><td>URI</td><td>(Optional) The uri to access the workflow file that describes the action chain of an AI agent.</td></tr></tbody></table>

#### **Trait Model Example**

A typical traits array from the metadata of a certain NFT is like:

```json
{
  "attributes": [ 
    {
      "trait_type": "Base", 
      "value": "Starfish"
    }, 
    {
      "trait_type": "Eyes", 
      "value": "Big"
    }, 
    {
      "trait_type": "Mouth", 
      "value": "Surprised"
    }, 
  ],
}
```

We need to convert it to:

```json
{
    "Base":"Starfish",
    "Eyes":"Big",
    "Mouth":"Surprised"
}
```

Then the `trait_model` could be like:

```
"You have these traits below:
- Base: {{Base}}, means the basic nation
- Eyes: {{Eyes}}, means what your eyes are look like
- Mouth: {{Mouth}}, means what your month are look like
- Influence: High, means your reputation
- Personality: Analytical, Pragmatic, Influential
"
```

We use [Jinja2](https://jinja.palletsprojects.com/en/3.1.x/) as the templating engine for trait model.`{{Base}}, {{Eyes}}, {{Mouth}}` are all placeholders in the template that will be replaced with `traits.Base`, `traits.Eyes` and `traits.Mouth` of a specific AI-NFT.

On the application side, after you retrieve `trait_model` , you can render the final prompts by filling in specific traits data with Jinja2.

#### Memory Structure

A single **memory** is described as a JSON file.

| Parameter     | Type   | Description                               |
| ------------- | ------ | ----------------------------------------- |
| `name`        | string | The name of this memory                   |
| `description` | string | (Optional) The description of this memory |
| `logo`        | string | (Optional) The logo url or the memory     |
| `memory`      | string | The serialized form of this memory.       |

#### Workflow Structure

A workflow is a configuration described as a JSON file.

|           |        |                                                                                                                                                                                                        |
| --------- | ------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `engine`  | string | The engine that can run the workflow given by `workflow.data`. For example, If the workflow originates from [dify.ai](https://dify.ai), or is compatible with this platform, set this field to “dify”. |
| `version` | number | (Optional) The engine version.                                                                                                                                                                         |
| `data`    | object | The DSL to describe the workflow of the AI agent.                                                                                                                                                      |

Based on this design, AI721 can support various current and future AI agent workflow protocols, and use the corresponding engines to run AI agent services.

#### URI Format Supported

<table><thead><tr><th width="332">Format</th><th>Description</th></tr></thead><tbody><tr><td>llm://{model}</td><td><p>Access a given LLM by calling APIs hosted by a party. This is only applicable for <code>llm</code>.</p><p>For examples:</p><ul><li><strong>"gpt-4"</strong> means gpt-4 model or its extended versions provided by OpenAI.</li><li><strong>"gemini-1.0"</strong> means gemini-1.0 model or its extended versions provided by Google.</li><li><strong>"any"</strong> means any LLMs can be used.</li></ul><p>*The name must follow the naming conventions used in the API parameters provided by major model manufacturers.</p><p></p><p>The application layer can determine how to access these models' API endpoints, for example, by registering a developer account at <a href="https://openai.com">openai.com.</a></p></td></tr><tr><td>ipfs://{cid}</td><td>The resources stored in IPFS/Filecoin. e.g. <code>ipfs://QmbWqxBEKC3P8tqsKc98xmWNzrzDtRLMiMPL8wBuTGsMnR</code></td></tr><tr><td>ar://{cid}</td><td>The resources stored in Arweave. e.g. <code>ar://k2g_3kYsPx-meD-AlyHhkUDYbUczlZ-M-bsKO6_oqY4</code></td></tr><tr><td>http(s)://{domain}/{path}</td><td>An typical http(s) url to locate resources.</td></tr><tr><td>... More formats from DePIN partners</td><td></td></tr></tbody></table>

### How to design a workflow

Check the [section](workflow.md).

### How to access the AI agents described by AI721?

1. Call `tokenURI`  by tokenId of an AI721 contract, and pull the AI metadata of the NFT.
2. Retrieve the LLM by `llm`  and run as a service;
3. Retrieve the trait model by `trait_model`. Input the traits set of the NFT to the model to obtain a set of prompts, and then integrate these prompts into the LLM you get in the previous step;
4. (Optional) Retrieve one of the public memories from the `public_memories` , and integrate it into the LLM you get in the previous step. This allows you to quickly create a predefined AI personality.
5. (Optional) Retrieve `workflow` and load it locally for the application layer to trigger at any time. If the workflow involves external LLMs, you can either replace them with the dedicated LLM from Step 4th or continue using the external LLM interface described by the DSL.

_After these steps, you'll get your AI agent ready to use, with a pre-defined personality._

## Implementing token URI of AI metadata

As what you have done for ERC721, you MUST implement `tokenURI`  and return a URI where we can find the metadata.&#x20;

## Best Practice

{% tabs %}
{% tab title="Merge AIMetadata with ERC721 metadata" %}
You can deploy an AI721 contract inherit from ERC721 to issue AI-NFT. In this way, y**ou MUST directly add new AIMetadata fields to ERC721 metadata.** The application layer will call `tokenURI(uint256 _tokenId)`  to access the metadata of an NFT and its AI personality directly.

### Merged Metadata Example

```json
// Merge AIMetadata with ERC721 metadata 
{
  // ERC721 metadata fields
  "description": "Friendly OpenSea Creature that enjoys long swims in the ocean.", 
  "external_url": "https://openseacreatures.io/3", 
  "image": "https://storage.googleapis.com/opensea-prod.appspot.com/puffs/3.png", 
  "name": "Dave Starbelly",
  "attributes": [ 
    {
      "trait_type": "Base", 
      "value": "Starfish"
    }, 
    {
      "trait_type": "Eyes", 
      "value": "Big"
    }, 
    {
      "trait_type": "Mouth", 
      "value": "Surprised"
    }, 
  ],
  // AI fields
  "llm":"llm://gpt-4",
  "trait_model":"
  - Base: {{Base}}
  - Eyes: {{Eyes}}
  - Mouth: {{Mouth}}
  - Influence: High
  - Personality: Analytical, Pragmatic, Influential
  ",
  "public_memories":"https://gonesis.ai/traveler/100/memories",
  "workflow":""
}
```
{% endtab %}

{% tab title="AILinker: Link ERC721 to AI721" %}
If your ERC721 contract was already deployed and you want to add AI capabilities for it, you need to deploy an independent AI721 contract, and use **AILinker (a public smart contract) to link your ERC721 contract to AI721 contract.**

### Token URI for AI metadata

The independent AI721 contract **MUST** implement `tokenURI`  and return a URI where we can find the metadata. This metadata **MUST** inherits from the original one and adds AI-related fields.

<pre class="language-solidity"><code class="lang-solidity"><strong>/**
</strong> * @dev Returns the metadata URI for a given token ID.
 */
function tokenURI(uint256 _tokenId) public view returns (string memory) {
  string memory baseAIMetadataURI = ''; // Base AI metadata uri for your collection
  return string(abi.encodePacked(
      baseAIMetadataURI,
      _toString(_tokenId)
  ));
}
</code></pre>

You can utilize an existing **AILinker** contract, or deploy your independent one. As the ecosystem grows, creators can link the same ERC721 contract to multiple AI721 contracts across different apps.

**Gonesis team will deploy an official AILinker contract, and provide a public UI to facilitate the link configuration for creators.**

### **AILinker Code Snippet**

```solidity
/**
 * @dev Links an ERC721 contract to multiple AI721 contracts.
 * @param erc721Contract The address of the ERC721 contract.
 * @param ai721Contracts An array of addresses representing the AI721 contracts to be linked.
 * 
 * Requirements:
 * 
 * - The caller must be the owner of the input erc721Contract
 * - The input ai721Contracts must impl aiMetadataURI
 */
function linkERC721ToAI721(address erc721Contract, address[] memory ai721Contracts) external {
    // Validate that the caller is the owner of the ERC721 contract
    require(msg.sender == Ownable(erc721Contract).owner(), "AILinker: Caller is not the owner of the ERC721 contract");
    // TODO: Add additional validation for ai721Contracts implementation of aiMetadataURI
    
    // Store the link between the ERC721 contract and the AI721 contracts
    links[erc721Contract] = ai721Contracts;
}

/**
 * @dev Retrieves the AI721 contracts linked to a specific ERC721 contract.
 * @param erc721Contract The address of the ERC721 contract.
 * @return An array of addresses representing the linked AI721 contracts.
 */
function getAI721Contracts(address erc721Contract) external view returns (address[] memory) {
    return links[erc721Contract];
}
```

### Best Practice

We assume you already have deployed an ERC721 contract. So there are the steps to link your ERC721 contract to an AI721 contract. By establishing this link, you can add AI personalities to the NFTs in your ERC721 collection, and enable interaction through the applications.

#### Step 1: Prepare AI metadata

Prepare AI metadata for your collection according to [AI Metadata Standard](ai721.md#ai-metadata-standard). If you want a quick start, you can choose from a selection of pre-trained AI metadata that we will make publicly available.

#### Step 2: Deploy AI721 contract

Deploy the AI721 contract for your ERC721 collection. This contract needs to implement the `tokenURI` interface to allow access to the AI metadata of the collection.

#### Step 3: Link ERC721 to AI721

You must link your ERC721 contract to the AI721 contract you just deployed, in an **AILinker** contract provided by the app layer. The app layer will use it to see which ERC721 is linked to a specific AI721 collection.

_These are the steps to link ERC721 to AI721. By following these steps, you can associate AI metadata with your ERC721 collection, and enable interaction with the AI721 applications._

_Please ensure to follow security best practices and perform proper testing and validation of your collection and contracts when deploying the contracts and configuration._
{% endtab %}
{% endtabs %}

**We recommend the application layer to firstly access AI metadata embedded in ERC721 contract to query AI personalities**. If not found, then use **AILinker** to query.

## Example

* [An example for Azuki](best-practice-the-example-of-azuki-collection.md)
* [An example for AI Agents](best-practice-the-example-of-ai-agent.md)
